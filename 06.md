
### Произведение. 

Известно, что такое произведение двух множеств - это набор пар (каждый с каждым). Необходимо определить шаблон для обобщения этого произведения для произвольной категории (не множества), т.е.
сопоставить элемент результата с элементами аргументов. 
Рассмотрим функции - проекции, возвращающие первый и второй аргумент пары соответственно:

fst (x, _) = x
snd (_, y) = y  

Попробуем определить искомый шаблон для категории множеств (опять же, не множества). Этот шаблон должен состоять (по построению, идем от обратного - берем результат и ищем морфизмы) из объекта c и двух морфизмов p и q, соединяющих его с объектами a и b.

p :: c -> a  
q :: c -> b  

Реальных функций p, q и результирующего проивзеднения с можно придумать сколько угодно - рассмотрим два корректных примера для исходных (умножаемых) типов Haskell Int и Bool.

1.(тривиальный) произведение с - это пара (Int, Bool) морфизм p не меняет аргумент, морфизм q переводит любое значение в True: 

p :: Int -> Int  
p x = x  
q :: Int -> Bool  
q _ = True  

2.(надуманный) произведение c - триплет типов (Int, Int, Bool), p не меняет первый аргумент, q не меняет третий аргумент, второй аргумент не проецируется:

p :: (Int, Int, Bool) -> Int  
p (x, _, _ ) = x  
q :: (Int, Int, Bool) -> Bool  
q (_, _, b) = b  

Далее введем ранжирование - необходимо сравнивать варианты c (и двух морфизмов) с другими вариантами. 
Сравнение будем делать с помощью факторизации - будем считать, что c, p, q лучше, чем с', p', q' если последние можно факторизовать (разложить на множители, точнее - на более простые морфизмы, см. рисунки). 

Для первого примера "фактором" m может быть:

m :: Int -> (Int, Bool)  
m x = (x, True)  

Для второго примера "фактор" m может быть:

m :: (Int, Int, Bool)  
m (x, _, b) = (x, b)  

Тогда в обоих случаях

p x = fst (m x) = x  
q x = snd (m x) = True   , т.е. формально "фактор" подходит. 
