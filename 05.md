### "С кем поведешься - от того и наберешься" как универсальный конструктор.

В теории категорий это означает: объект определяется (с точностью до изоморфизма) своими отношениями (морфизмами) с другими объектами. 
Выделение объекта в категории происходит через определение шаблона - набора объектов и морфизмов, который может быть более или менее точным. 
Так, конкретный запрос (шаблон) в поисковой системе приводит к меньшему числу ответов в выдаче (0 поисковых ответов в пределе), а общий - к большему (все сайты сети в пределе). 
Обратим внимание, что ответы поисковой системы ранжированы. 

### Исходный и конечный объект.

Выберем шаблон, возвращающий все объекты в категории. Для определения рангов будем использовать морфизмы, полагая что если существует морфизм a->b, то a - "более исходный", чем b, а b - "более конечный", чем a.

Определим a как исходный, если для любого объекта b, существует единственный морфизм a->b. Если таких объектов несколько, то определение корректно с точностью до изоморфизма. 
В частично упорядоченном множестве, исходный объект - наименьший. В категории множеств и функци исходный объект - пустое множество. В С++ не существует. В Haskell - тип Void (функция absurd :: Void -> a). 

Аналогично определим (с точностью до изоморфизма): конечный объект b - в который существует единственный морфизм a->b для любого объекта a. 
В частично упорядоченном множестве, конечный объект - наибольший. В категории множеств и функций конечный объект - одноэлементное множество. В С++ - тип void. В Haskell - тип () (функция   
unit :: a -> ()  
unit _ = ())

### Двойственность - 

Это свойство, позволяющее изменить направление всех морфизмов с сохранением структуры категории. 
Так, исходный объект в множестве, двойственнном к частично упорядоченному множеству является конечным объектом (отношение больше или равно переходит в меньше или равно). 

### Изоморфизм. 

Определение отношения равенства - нетривиальная задача. 
В программировании равенство может определяться как совпадение значений, совпадение адресов памяти, совпадение после неявного преобразования и т.д.
Примитивное "Если два треугольника можно совместить наложением, то они равны" - глубже, чем может показаться. Обозначим наложение объекта a на объект b как морфизм a->b, тогда наложение b на a есть двойственный морфизм. 
Вместе эта пара образует изоморфизм - отношение общности строения объектов. В теории категорий, морфизмы f и g образуют изоморфизм, если их композиция(f.g и g.f) - тождественный морфизм (id).
Обратим внимание, что оговорка "с точностью до изоморфизма" подразумевает единственность тождественного морфизма - если бы их было несколько, композиции f.g и g.f были бы неоднозначны. 

### Произведение. 

Известно, что такое произведение двух множеств - это набор пар. Необходимо определить шаблон - соответсвие результирующего множества и его компонентов.
В наших руках есть только функции - проекции:

fst :: (a, b) -> a  
fst (x, y) = x  
snd :: (a, b) -> b  
snd (x, y) = y  

С этим небольшим арсеналом, попробуем определить шаблон объектов и морфизмов в категории множеств. Этот шаблон состоит из объекта c и двух морфизмов p и q, соединяющих его с объектами a и b.

p :: c -> a  
q :: c -> b  

Все возможные варианты c (их может быть много) - кандидаты на результирующее произведение. Поясним на тривиальном примере с типами Int, Bool:

p :: Int -> Int
p x = x
q :: Int -> Bool
q _ = True

А также на надуманном примере с типами (Int, Int, Bool):

p :: (Int, Int, Bool) -> Int
p (x, _, _ ) = x
q :: (Int, Int, Bool) -> Bool
q (_, _, b) = b

Далее введем ранжирование - необходимо сравнивать варианты c (и двух морфизмов) с другими вариантами. 
Сравнение будем делать с помощью факторизации - будем считать, что c, p, q лучше, чем с', p', q' если последние можно факторизовать (разложить на множители, точнее - на более простые морфизмы, см. рисунки). 

Для первого примера "фактором" m может быть:

m :: Int -> (Int, Bool)
m x = (x, True)

Для второго примера "фактор" m может быть:

m :: (Int, Int, Bool)
m (x, _, b) = (x, b)

Тогда в обоих случаях

p x = fst (m x) = x
q x = snd (m x) = True , т.е. формально "фактор" подходит. 









