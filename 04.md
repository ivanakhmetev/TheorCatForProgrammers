### Категория Клейсли - 

Это категория, основанная на монаде. Монада (обсуждается позднее) - объект теории категорий, имитирующий поведения моноида.
Далее рассматривается програмный пример без теории.

### Выделение логгирования как побочного эффекта

Рассматривается функция f с побочным эффектом - изменение глобальной переменной (добавление записи в лог).
Такая функция по определению не является чистой, что также подтверждается разницей в работе f и memoize(f).
Функцию f можно сделать чистой, явно передав аргумент лога (и вернув измененный). Однако это неудобно, т.к. придется хранить не 1 переменную для лога а множество, что убивает смысл логгирования.
Далее уберем аргумент функции, но оставим возвращаемое значение лога - какую-то отметку о работе функции, что бы собирать лог после вызова f.

### Композиция чистых функций

Возьмем две функции: переводящую строковые буквы в заглавные и разделяющую предложение на слова. 
Первая принимает строку и возвращает строку, вторая принимает строку, а возвращает список.
Приведем эти функции к виду, аналогичному последнему пункту предыдущего абзаца: чистые функции, вместе с возвращаемым значением возвращающие сообщение (возвращается кортеж).
Определим функцию, комбинирующую работы предыдущих. Эта функция вызывает первую от исходного аргумента и вторую от возвращаемого значения первый, сохраняя сообщения о работе функций.
Таким образом, получается чистая комбинация (композиция) чистых функций, выполняющая логгирование (исходно побочное). 
Несмотря на функциональную чистоту, код является плохим. Для его улучшения рассматривается абстрагирование композиции. 


### Композиция как категория

Добавочная функциональность (логирование) с сохранением чистоты плодотворна. Стандартным инструментом Python для этого являются декораторы (исходный код книги на c++, по ссылке на python, декораторы как таковые не используются для сохранения стиля автора, но функции, возвращающие дополнительно сообщение о своей работе вообще говоря являются декорированными). 
Рассмотрим категорию, где объекты - типы, морфизмы - декорированные функции. Существенно, что "декорация" (сообщение о работе функции) не меняет морфизм как переход между типами (в примерах - строка -> строка, строка -> список).
Т.е. декорация не меняет свойств композиции (если есть стрелка A->B и стрелка B->C, то должна быть и стрелка A->C).
Следовательно, можно записать композицию наших функций как функцию высшего порядка.
Добавим теперь морфизм в себя, возвращающий исходный аргумент и пустую лог - строку.
И проверим работу композиции. Композиция ассоциативна, существует морфизм в себя - получилась категория. 








